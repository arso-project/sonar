// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

var encodings = require('hrpc-runtime/encodings')
var varint = encodings.varint
var skip = encodings.skip

var Json = exports.Json = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Link = exports.Link = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Arg = exports.Arg = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var RemoteError = exports.RemoteError = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CommandSpec = exports.CommandSpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var QuerySpec = exports.QuerySpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ArgSpec = exports.ArgSpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Record = exports.Record = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Feed = exports.Feed = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OpenRequest = exports.OpenRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OpenResponse = exports.OpenResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var InfoRequest = exports.InfoRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var InfoResponse = exports.InfoResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var FeedsRequest = exports.FeedsRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var FeedsResponse = exports.FeedsResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SchemaRequest = exports.SchemaRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SchemaResponse = exports.SchemaResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Type = exports.Type = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Field = exports.Field = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var GetRequest = exports.GetRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var GetResponse = exports.GetResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var QueryRequest = exports.QueryRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var QueryResponse = exports.QueryResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CancelQueryRequest = exports.CancelQueryRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PublishRequest = exports.PublishRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PublishResponse = exports.PublishResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SubscribeRequest = exports.SubscribeRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SubscribeResponse = exports.SubscribeResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PullRequest = exports.PullRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PullResponse = exports.PullResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var AckRequest = exports.AckRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var AckResponse = exports.AckResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OnResultsRequest = exports.OnResultsRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var OnUpdateRequest = exports.OnUpdateRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SyncRequest = exports.SyncRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CommandRequest = exports.CommandRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CommandResponse = exports.CommandResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var StreamRequest = exports.StreamRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var StatusResponse = exports.StatusResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var CommandStatus = exports.CommandStatus = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var RPCError = exports.RPCError = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Map_string_bytes = exports.Map_string_bytes = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Map_string_Type = exports.Map_string_Type = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Map_string_string = exports.Map_string_string = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineJson()
defineLink()
defineArg()
defineRemoteError()
defineCommandSpec()
defineQuerySpec()
defineArgSpec()
defineRecord()
defineFeed()
defineOpenRequest()
defineOpenResponse()
defineInfoRequest()
defineInfoResponse()
defineFeedsRequest()
defineFeedsResponse()
defineSchemaRequest()
defineSchemaResponse()
defineType()
defineField()
defineGetRequest()
defineGetResponse()
defineQueryRequest()
defineQueryResponse()
defineCancelQueryRequest()
definePublishRequest()
definePublishResponse()
defineSubscribeRequest()
defineSubscribeResponse()
definePullRequest()
definePullResponse()
defineAckRequest()
defineAckResponse()
defineOnResultsRequest()
defineOnUpdateRequest()
defineSyncRequest()
defineCommandRequest()
defineCommandResponse()
defineStreamRequest()
defineStatusResponse()
defineCommandStatus()
defineRPCError()
defineMap_string_bytes()
defineMap_string_Type()
defineMap_string_string()

function defineJson () {
  Json.encodingLength = encodingLength
  Json.encode = encode
  Json.decode = decode

  function encodingLength (obj) {
    var length = 0
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLink () {
  Link.encodingLength = encodingLength
  Link.encode = encode
  Link.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.bytes.encodingLength(obj.key)
    length += 1 + len
    if (!defined(obj.seq)) throw new Error("seq is required")
    var len = encodings.varint.encodingLength(obj.seq)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.bytes.encode(obj.key, buf, offset)
    offset += encodings.bytes.encode.bytes
    if (!defined(obj.seq)) throw new Error("seq is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.seq, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: null,
      seq: 0
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        found0 = true
        break
        case 2:
        obj.seq = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineArg () {
  Arg.encodingLength = encodingLength
  Arg.encode = encode
  Arg.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (!defined(obj.value)) throw new Error("value is required")
    var len = encodings.bytes.encodingLength(obj.value)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.name)) {
      buf[offset++] = 10
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (!defined(obj.value)) throw new Error("value is required")
    buf[offset++] = 18
    encodings.bytes.encode(obj.value, buf, offset)
    offset += encodings.bytes.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      value: null
    }
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRemoteError () {
  RemoteError.encodingLength = encodingLength
  RemoteError.encode = encode
  RemoteError.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.reason)) {
      var len = encodings.string.encodingLength(obj.reason)
      length += 1 + len
    }
    if (defined(obj.code)) {
      var len = encodings.varint.encodingLength(obj.code)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.reason)) {
      buf[offset++] = 10
      encodings.string.encode(obj.reason, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.code)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.code, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      reason: "",
      code: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.reason = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.code = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCommandSpec () {
  CommandSpec.encodingLength = encodingLength
  CommandSpec.encode = encode
  CommandSpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        var len = ArgSpec.encodingLength(obj.args[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.streaming)) {
      var len = encodings.bool.encodingLength(obj.streaming)
      length += 1 + len
    }
    if (defined(obj.replying)) {
      var len = encodings.bool.encodingLength(obj.replying)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 10
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        buf[offset++] = 18
        varint.encode(ArgSpec.encodingLength(obj.args[i]), buf, offset)
        offset += varint.encode.bytes
        ArgSpec.encode(obj.args[i], buf, offset)
        offset += ArgSpec.encode.bytes
      }
    }
    if (defined(obj.streaming)) {
      buf[offset++] = 24
      encodings.bool.encode(obj.streaming, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.replying)) {
      buf[offset++] = 32
      encodings.bool.encode(obj.replying, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      args: [],
      streaming: false,
      replying: false
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.args.push(ArgSpec.decode(buf, offset, offset + len))
        offset += ArgSpec.decode.bytes
        break
        case 3:
        obj.streaming = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 4:
        obj.replying = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineQuerySpec () {
  QuerySpec.encodingLength = encodingLength
  QuerySpec.encode = encode
  QuerySpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        var len = ArgSpec.encodingLength(obj.args[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 10
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        buf[offset++] = 18
        varint.encode(ArgSpec.encodingLength(obj.args[i]), buf, offset)
        offset += varint.encode.bytes
        ArgSpec.encode(obj.args[i], buf, offset)
        offset += ArgSpec.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      args: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.args.push(ArgSpec.decode(buf, offset, offset + len))
        offset += ArgSpec.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineArgSpec () {
  ArgSpec.encodingLength = encodingLength
  ArgSpec.encode = encode
  ArgSpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (!defined(obj.type)) throw new Error("type is required")
    var len = encodings.string.encodingLength(obj.type)
    length += 1 + len
    if (defined(obj.alias)) {
      var len = encodings.string.encodingLength(obj.alias)
      length += 1 + len
    }
    if (defined(obj.description)) {
      var len = encodings.string.encodingLength(obj.description)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 10
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.type)) throw new Error("type is required")
    buf[offset++] = 18
    encodings.string.encode(obj.type, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.alias)) {
      buf[offset++] = 26
      encodings.string.encode(obj.alias, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.description)) {
      buf[offset++] = 34
      encodings.string.encode(obj.description, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      type: "",
      alias: "",
      description: ""
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.type = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        obj.alias = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 4:
        obj.description = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRecord () {
  Record.encodingLength = encodingLength
  Record.encode = encode
  Record.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.string.encodingLength(obj.id)
    length += 1 + len
    if (!defined(obj.type)) throw new Error("type is required")
    var len = encodings.string.encodingLength(obj.type)
    length += 1 + len
    if (defined(obj.deleted)) {
      var len = encodings.bool.encodingLength(obj.deleted)
      length += 1 + len
    }
    if (defined(obj.value)) {
      var len = encodings.bytes.encodingLength(obj.value)
      length += 1 + len
    }
    if (defined(obj.timestamp)) {
      var len = encodings.varint.encodingLength(obj.timestamp)
      length += 1 + len
    }
    if (defined(obj.links)) {
      for (var i = 0; i < obj.links.length; i++) {
        if (!defined(obj.links[i])) continue
        var len = encodings.string.encodingLength(obj.links[i])
        length += 1 + len
      }
    }
    if (defined(obj.feed)) {
      var len = encodings.bytes.encodingLength(obj.feed)
      length += 1 + len
    }
    if (defined(obj.seq)) {
      var len = encodings.varint.encodingLength(obj.seq)
      length += 1 + len
    }
    if (defined(obj.lseq)) {
      var len = encodings.varint.encodingLength(obj.lseq)
      length += 1 + len
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_bytes.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 2 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 10
    encodings.string.encode(obj.id, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.type)) throw new Error("type is required")
    buf[offset++] = 18
    encodings.string.encode(obj.type, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.deleted)) {
      buf[offset++] = 24
      encodings.bool.encode(obj.deleted, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.value)) {
      buf[offset++] = 34
      encodings.bytes.encode(obj.value, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.timestamp)) {
      buf[offset++] = 40
      encodings.varint.encode(obj.timestamp, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.links)) {
      for (var i = 0; i < obj.links.length; i++) {
        if (!defined(obj.links[i])) continue
        buf[offset++] = 58
        encodings.string.encode(obj.links[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    if (defined(obj.feed)) {
      buf[offset++] = 106
      encodings.bytes.encode(obj.feed, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.seq)) {
      buf[offset++] = 112
      encodings.varint.encode(obj.seq, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.lseq)) {
      buf[offset++] = 120
      encodings.varint.encode(obj.lseq, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 130
        buf[offset++] = 1
        varint.encode(Map_string_bytes.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_bytes.encode(tmp[i], buf, offset)
        offset += Map_string_bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: "",
      type: "",
      deleted: false,
      value: null,
      timestamp: 0,
      links: [],
      feed: null,
      seq: 0,
      lseq: 0,
      meta: {}
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.type = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        obj.deleted = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 4:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 5:
        obj.timestamp = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 7:
        obj.links.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        case 13:
        obj.feed = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 14:
        obj.seq = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 15:
        obj.lseq = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 16:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_bytes.decode(buf, offset, offset + len)
        obj.meta[tmp.key] = tmp.value
        offset += Map_string_bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineFeed () {
  Feed.encodingLength = encodingLength
  Feed.encode = encode
  Feed.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.bytes.encodingLength(obj.key)
    length += 1 + len
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (!defined(obj.length)) throw new Error("length is required")
    var len = encodings.varint.encodingLength(obj.length)
    length += 1 + len
    if (!defined(obj.byteLength)) throw new Error("byteLength is required")
    var len = encodings.varint.encodingLength(obj.byteLength)
    length += 1 + len
    if (!defined(obj.writable)) throw new Error("writable is required")
    var len = encodings.bool.encodingLength(obj.writable)
    length += 1 + len
    if (!defined(obj.type)) throw new Error("type is required")
    var len = encodings.string.encodingLength(obj.type)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.bytes.encode(obj.key, buf, offset)
    offset += encodings.bytes.encode.bytes
    if (defined(obj.name)) {
      buf[offset++] = 18
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (!defined(obj.length)) throw new Error("length is required")
    buf[offset++] = 24
    encodings.varint.encode(obj.length, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.byteLength)) throw new Error("byteLength is required")
    buf[offset++] = 32
    encodings.varint.encode(obj.byteLength, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.writable)) throw new Error("writable is required")
    buf[offset++] = 40
    encodings.bool.encode(obj.writable, buf, offset)
    offset += encodings.bool.encode.bytes
    if (!defined(obj.type)) throw new Error("type is required")
    buf[offset++] = 50
    encodings.string.encode(obj.type, buf, offset)
    offset += encodings.string.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: null,
      name: "",
      length: 0,
      byteLength: 0,
      writable: false,
      type: ""
    }
    var found0 = false
    var found2 = false
    var found3 = false
    var found4 = false
    var found5 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found2 || !found3 || !found4 || !found5) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        found0 = true
        break
        case 2:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.length = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found2 = true
        break
        case 4:
        obj.byteLength = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found3 = true
        break
        case 5:
        obj.writable = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        found4 = true
        break
        case 6:
        obj.type = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found5 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOpenRequest () {
  OpenRequest.encodingLength = encodingLength
  OpenRequest.encode = encode
  OpenRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.key)) {
      var len = encodings.bytes.encodingLength(obj.key)
      length += 1 + len
    }
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (defined(obj.token)) {
      var len = encodings.string.encodingLength(obj.token)
      length += 1 + len
    }
    if (defined(obj.cacheid)) {
      var len = encodings.string.encodingLength(obj.cacheid)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.key)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.key, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.name)) {
      buf[offset++] = 26
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.token)) {
      buf[offset++] = 34
      encodings.string.encode(obj.token, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.cacheid)) {
      buf[offset++] = 42
      encodings.string.encode(obj.cacheid, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      key: null,
      name: "",
      token: "",
      cacheid: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.key = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 4:
        obj.token = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.cacheid = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOpenResponse () {
  OpenResponse.encodingLength = encodingLength
  OpenResponse.encode = encode
  OpenResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.bytes.encodingLength(obj.key)
    length += 1 + len
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (defined(obj.total)) {
      var len = encodings.varint.encodingLength(obj.total)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.bytes.encode(obj.key, buf, offset)
    offset += encodings.bytes.encode.bytes
    if (defined(obj.name)) {
      buf[offset++] = 18
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.total)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.total, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: null,
      name: "",
      total: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        found0 = true
        break
        case 2:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.total = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineInfoRequest () {
  InfoRequest.encodingLength = encodingLength
  InfoRequest.encode = encode
  InfoRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineInfoResponse () {
  InfoResponse.encodingLength = encodingLength
  InfoResponse.encode = encode
  InfoResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.queries)) {
      for (var i = 0; i < obj.queries.length; i++) {
        if (!defined(obj.queries[i])) continue
        var len = QuerySpec.encodingLength(obj.queries[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.commands)) {
      for (var i = 0; i < obj.commands.length; i++) {
        if (!defined(obj.commands[i])) continue
        var len = CommandSpec.encodingLength(obj.commands[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.queries)) {
      for (var i = 0; i < obj.queries.length; i++) {
        if (!defined(obj.queries[i])) continue
        buf[offset++] = 10
        varint.encode(QuerySpec.encodingLength(obj.queries[i]), buf, offset)
        offset += varint.encode.bytes
        QuerySpec.encode(obj.queries[i], buf, offset)
        offset += QuerySpec.encode.bytes
      }
    }
    if (defined(obj.commands)) {
      for (var i = 0; i < obj.commands.length; i++) {
        if (!defined(obj.commands[i])) continue
        buf[offset++] = 18
        varint.encode(CommandSpec.encodingLength(obj.commands[i]), buf, offset)
        offset += varint.encode.bytes
        CommandSpec.encode(obj.commands[i], buf, offset)
        offset += CommandSpec.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      queries: [],
      commands: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.queries.push(QuerySpec.decode(buf, offset, offset + len))
        offset += QuerySpec.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.commands.push(CommandSpec.decode(buf, offset, offset + len))
        offset += CommandSpec.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineFeedsRequest () {
  FeedsRequest.encodingLength = encodingLength
  FeedsRequest.encode = encode
  FeedsRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineFeedsResponse () {
  FeedsResponse.encodingLength = encodingLength
  FeedsResponse.encode = encode
  FeedsResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.feeds)) {
      for (var i = 0; i < obj.feeds.length; i++) {
        if (!defined(obj.feeds[i])) continue
        var len = Feed.encodingLength(obj.feeds[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.feeds)) {
      for (var i = 0; i < obj.feeds.length; i++) {
        if (!defined(obj.feeds[i])) continue
        buf[offset++] = 10
        varint.encode(Feed.encodingLength(obj.feeds[i]), buf, offset)
        offset += varint.encode.bytes
        Feed.encode(obj.feeds[i], buf, offset)
        offset += Feed.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      feeds: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.feeds.push(Feed.decode(buf, offset, offset + len))
        offset += Feed.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSchemaRequest () {
  SchemaRequest.encodingLength = encodingLength
  SchemaRequest.encode = encode
  SchemaRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.wait)) {
      var len = encodings.bool.encodingLength(obj.wait)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.wait)) {
      buf[offset++] = 16
      encodings.bool.encode(obj.wait, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      wait: false
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.wait = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSchemaResponse () {
  SchemaResponse.encodingLength = encodingLength
  SchemaResponse.encode = encode
  SchemaResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.types)) {
      var tmp = Object.keys(obj.types)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.types[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_Type.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (!defined(obj.version)) throw new Error("version is required")
    var len = encodings.varint.encodingLength(obj.version)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.types)) {
      var tmp = Object.keys(obj.types)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.types[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 10
        varint.encode(Map_string_Type.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_Type.encode(tmp[i], buf, offset)
        offset += Map_string_Type.encode.bytes
      }
    }
    if (!defined(obj.version)) throw new Error("version is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.version, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      types: {},
      version: 0
    }
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_Type.decode(buf, offset, offset + len)
        obj.types[tmp.key] = tmp.value
        offset += Map_string_Type.decode.bytes
        break
        case 2:
        obj.version = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineType () {
  Type.encodingLength = encodingLength
  Type.encode = encode
  Type.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.namespace)) throw new Error("namespace is required")
    var len = encodings.string.encodingLength(obj.namespace)
    length += 1 + len
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (!defined(obj.version)) throw new Error("version is required")
    var len = encodings.varint.encodingLength(obj.version)
    length += 1 + len
    if (defined(obj.title)) {
      var len = encodings.string.encodingLength(obj.title)
      length += 1 + len
    }
    if (defined(obj.description)) {
      var len = encodings.string.encodingLength(obj.description)
      length += 1 + len
    }
    if (defined(obj.fields)) {
      for (var i = 0; i < obj.fields.length; i++) {
        if (!defined(obj.fields[i])) continue
        var len = Field.encodingLength(obj.fields[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.namespace)) throw new Error("namespace is required")
    buf[offset++] = 10
    encodings.string.encode(obj.namespace, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 18
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.version)) throw new Error("version is required")
    buf[offset++] = 24
    encodings.varint.encode(obj.version, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.title)) {
      buf[offset++] = 34
      encodings.string.encode(obj.title, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.description)) {
      buf[offset++] = 42
      encodings.string.encode(obj.description, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.fields)) {
      for (var i = 0; i < obj.fields.length; i++) {
        if (!defined(obj.fields[i])) continue
        buf[offset++] = 50
        varint.encode(Field.encodingLength(obj.fields[i]), buf, offset)
        offset += varint.encode.bytes
        Field.encode(obj.fields[i], buf, offset)
        offset += Field.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      namespace: "",
      name: "",
      version: 0,
      title: "",
      description: "",
      fields: []
    }
    var found0 = false
    var found1 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.namespace = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        obj.version = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found2 = true
        break
        case 4:
        obj.title = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.description = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 6:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.fields.push(Field.decode(buf, offset, offset + len))
        offset += Field.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineField () {
  Field.encodingLength = encodingLength
  Field.encode = encode
  Field.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (!defined(obj.fieldType)) throw new Error("fieldType is required")
    var len = encodings.string.encodingLength(obj.fieldType)
    length += 1 + len
    if (defined(obj.refines)) {
      var len = encodings.string.encodingLength(obj.refines)
      length += 1 + len
    }
    if (defined(obj.title)) {
      var len = encodings.string.encodingLength(obj.title)
      length += 1 + len
    }
    if (defined(obj.description)) {
      var len = encodings.string.encodingLength(obj.description)
      length += 1 + len
    }
    if (defined(obj.index)) {
      var tmp = Object.keys(obj.index)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.index[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_bytes.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_bytes.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 10
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.fieldType)) throw new Error("fieldType is required")
    buf[offset++] = 18
    encodings.string.encode(obj.fieldType, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.refines)) {
      buf[offset++] = 26
      encodings.string.encode(obj.refines, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.title)) {
      buf[offset++] = 34
      encodings.string.encode(obj.title, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.description)) {
      buf[offset++] = 42
      encodings.string.encode(obj.description, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.index)) {
      var tmp = Object.keys(obj.index)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.index[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 50
        varint.encode(Map_string_bytes.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_bytes.encode(tmp[i], buf, offset)
        offset += Map_string_bytes.encode.bytes
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 58
        varint.encode(Map_string_bytes.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_bytes.encode(tmp[i], buf, offset)
        offset += Map_string_bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      fieldType: "",
      refines: "",
      title: "",
      description: "",
      index: {},
      meta: {}
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.fieldType = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        obj.refines = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 4:
        obj.title = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.description = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 6:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_bytes.decode(buf, offset, offset + len)
        obj.index[tmp.key] = tmp.value
        offset += Map_string_bytes.decode.bytes
        break
        case 7:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_bytes.decode(buf, offset, offset + len)
        obj.meta[tmp.key] = tmp.value
        offset += Map_string_bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineGetRequest () {
  GetRequest.encodingLength = encodingLength
  GetRequest.encode = encode
  GetRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.lseq)) {
      var len = encodings.varint.encodingLength(obj.lseq)
      length += 1 + len
    }
    if (defined(obj.address)) {
      var len = Link.encodingLength(obj.address)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.lseq)) {
      buf[offset++] = 8
      encodings.varint.encode(obj.lseq, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.address)) {
      buf[offset++] = 18
      varint.encode(Link.encodingLength(obj.address), buf, offset)
      offset += varint.encode.bytes
      Link.encode(obj.address, buf, offset)
      offset += Link.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      lseq: 0,
      address: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.lseq = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.address = Link.decode(buf, offset, offset + len)
        offset += Link.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineGetResponse () {
  GetResponse.encodingLength = encodingLength
  GetResponse.encode = encode
  GetResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.lseq)) {
      var len = encodings.varint.encodingLength(obj.lseq)
      length += 1 + len
    }
    if (defined(obj.address)) {
      var len = Link.encodingLength(obj.address)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.record)) {
      var len = Record.encodingLength(obj.record)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.lseq)) {
      buf[offset++] = 8
      encodings.varint.encode(obj.lseq, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.address)) {
      buf[offset++] = 18
      varint.encode(Link.encodingLength(obj.address), buf, offset)
      offset += varint.encode.bytes
      Link.encode(obj.address, buf, offset)
      offset += Link.encode.bytes
    }
    if (defined(obj.record)) {
      buf[offset++] = 26
      varint.encode(Record.encodingLength(obj.record), buf, offset)
      offset += varint.encode.bytes
      Record.encode(obj.record, buf, offset)
      offset += Record.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      lseq: 0,
      address: null,
      record: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.lseq = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.address = Link.decode(buf, offset, offset + len)
        offset += Link.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.record = Record.decode(buf, offset, offset + len)
        offset += Record.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineQueryRequest () {
  QueryRequest.encodingLength = encodingLength
  QueryRequest.encode = encode
  QueryRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.resourceId)) {
      var len = encodings.varint.encodingLength(obj.resourceId)
      length += 1 + len
    }
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (defined(obj.args)) {
      var len = encodings.bytes.encodingLength(obj.args)
      length += 1 + len
    }
    if (defined(obj.stream)) {
      var len = encodings.bool.encodingLength(obj.stream)
      length += 1 + len
    }
    if (defined(obj.live)) {
      var len = encodings.bool.encodingLength(obj.live)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.resourceId)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.resourceId, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 26
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.args)) {
      buf[offset++] = 34
      encodings.bytes.encode(obj.args, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.stream)) {
      buf[offset++] = 40
      encodings.bool.encode(obj.stream, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.live)) {
      buf[offset++] = 48
      encodings.bool.encode(obj.live, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      resourceId: 0,
      name: "",
      args: null,
      stream: false,
      live: false
    }
    var found0 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found2 = true
        break
        case 4:
        obj.args = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 5:
        obj.stream = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 6:
        obj.live = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineQueryResponse () {
  QueryResponse.encodingLength = encodingLength
  QueryResponse.encode = encode
  QueryResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        var len = Record.encodingLength(obj.records[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_bytes.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        buf[offset++] = 10
        varint.encode(Record.encodingLength(obj.records[i]), buf, offset)
        offset += varint.encode.bytes
        Record.encode(obj.records[i], buf, offset)
        offset += Record.encode.bytes
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 18
        varint.encode(Map_string_bytes.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_bytes.encode(tmp[i], buf, offset)
        offset += Map_string_bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      records: [],
      meta: {}
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.records.push(Record.decode(buf, offset, offset + len))
        offset += Record.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_bytes.decode(buf, offset, offset + len)
        obj.meta[tmp.key] = tmp.value
        offset += Map_string_bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCancelQueryRequest () {
  CancelQueryRequest.encodingLength = encodingLength
  CancelQueryRequest.encode = encode
  CancelQueryRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      resourceId: 0
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePublishRequest () {
  PublishRequest.encodingLength = encodingLength
  PublishRequest.encode = encode
  PublishRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        var len = Record.encodingLength(obj.records[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        buf[offset++] = 18
        varint.encode(Record.encodingLength(obj.records[i]), buf, offset)
        offset += varint.encode.bytes
        Record.encode(obj.records[i], buf, offset)
        offset += Record.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      records: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.records.push(Record.decode(buf, offset, offset + len))
        offset += Record.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePublishResponse () {
  PublishResponse.encodingLength = encodingLength
  PublishResponse.encode = encode
  PublishResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        var len = Link.encodingLength(obj.records[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        buf[offset++] = 10
        varint.encode(Link.encodingLength(obj.records[i]), buf, offset)
        offset += varint.encode.bytes
        Link.encode(obj.records[i], buf, offset)
        offset += Link.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      records: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.records.push(Link.decode(buf, offset, offset + len))
        offset += Link.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSubscribeRequest () {
  SubscribeRequest.encodingLength = encodingLength
  SubscribeRequest.encode = encode
  SubscribeRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (!defined(obj.persist)) throw new Error("persist is required")
    var len = encodings.bool.encodingLength(obj.persist)
    length += 1 + len
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (defined(obj.start)) {
      var len = encodings.varint.encodingLength(obj.start)
      length += 1 + len
    }
    if (defined(obj.end)) {
      var len = encodings.varint.encodingLength(obj.end)
      length += 1 + len
    }
    if (defined(obj.reverse)) {
      var len = encodings.bool.encodingLength(obj.reverse)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.persist)) throw new Error("persist is required")
    buf[offset++] = 24
    encodings.bool.encode(obj.persist, buf, offset)
    offset += encodings.bool.encode.bytes
    if (defined(obj.name)) {
      buf[offset++] = 34
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.start)) {
      buf[offset++] = 40
      encodings.varint.encode(obj.start, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.end)) {
      buf[offset++] = 48
      encodings.varint.encode(obj.end, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.reverse)) {
      buf[offset++] = 56
      encodings.bool.encode(obj.reverse, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      resourceId: 0,
      persist: false,
      name: "",
      start: 0,
      end: 0,
      reverse: false
    }
    var found0 = false
    var found1 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.persist = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        found2 = true
        break
        case 4:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.start = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 6:
        obj.end = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 7:
        obj.reverse = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSubscribeResponse () {
  SubscribeResponse.encodingLength = encodingLength
  SubscribeResponse.encode = encode
  SubscribeResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    var len = encodings.varint.encodingLength(obj.cursor)
    length += 1 + len
    if (!defined(obj.total)) throw new Error("total is required")
    var len = encodings.varint.encodingLength(obj.total)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.cursor, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.total)) throw new Error("total is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.total, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      cursor: 0,
      total: 0
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.cursor = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.total = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePullRequest () {
  PullRequest.encodingLength = encodingLength
  PullRequest.encode = encode
  PullRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      resourceId: 0
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePullResponse () {
  PullResponse.encodingLength = encodingLength
  PullResponse.encode = encode
  PullResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.messages)) {
      for (var i = 0; i < obj.messages.length; i++) {
        if (!defined(obj.messages[i])) continue
        var len = Record.encodingLength(obj.messages[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    var len = encodings.varint.encodingLength(obj.cursor)
    length += 1 + len
    if (!defined(obj.finished)) throw new Error("finished is required")
    var len = encodings.bool.encodingLength(obj.finished)
    length += 1 + len
    if (!defined(obj.total)) throw new Error("total is required")
    var len = encodings.varint.encodingLength(obj.total)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.messages)) {
      for (var i = 0; i < obj.messages.length; i++) {
        if (!defined(obj.messages[i])) continue
        buf[offset++] = 10
        varint.encode(Record.encodingLength(obj.messages[i]), buf, offset)
        offset += varint.encode.bytes
        Record.encode(obj.messages[i], buf, offset)
        offset += Record.encode.bytes
      }
    }
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.cursor, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.finished)) throw new Error("finished is required")
    buf[offset++] = 24
    encodings.bool.encode(obj.finished, buf, offset)
    offset += encodings.bool.encode.bytes
    if (!defined(obj.total)) throw new Error("total is required")
    buf[offset++] = 32
    encodings.varint.encode(obj.total, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      messages: [],
      cursor: 0,
      finished: false,
      total: 0
    }
    var found1 = false
    var found2 = false
    var found3 = false
    while (true) {
      if (end <= offset) {
        if (!found1 || !found2 || !found3) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.messages.push(Record.decode(buf, offset, offset + len))
        offset += Record.decode.bytes
        break
        case 2:
        obj.cursor = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.finished = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        found2 = true
        break
        case 4:
        obj.total = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found3 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAckRequest () {
  AckRequest.encodingLength = encodingLength
  AckRequest.encode = encode
  AckRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    var len = encodings.varint.encodingLength(obj.cursor)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.cursor, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      resourceId: 0,
      cursor: 0
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.cursor = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAckResponse () {
  AckResponse.encodingLength = encodingLength
  AckResponse.encode = encode
  AckResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    var len = encodings.varint.encodingLength(obj.cursor)
    length += 1 + len
    if (!defined(obj.total)) throw new Error("total is required")
    var len = encodings.varint.encodingLength(obj.total)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.cursor)) throw new Error("cursor is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.cursor, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.total)) throw new Error("total is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.total, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      cursor: 0,
      total: 0
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.cursor = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.total = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOnResultsRequest () {
  OnResultsRequest.encodingLength = encodingLength
  OnResultsRequest.encode = encode
  OnResultsRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        var len = Record.encodingLength(obj.records[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_bytes.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.finished)) {
      var len = encodings.bool.encodingLength(obj.finished)
      length += 1 + len
    }
    if (defined(obj.error)) {
      var len = RemoteError.encodingLength(obj.error)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.records)) {
      for (var i = 0; i < obj.records.length; i++) {
        if (!defined(obj.records[i])) continue
        buf[offset++] = 18
        varint.encode(Record.encodingLength(obj.records[i]), buf, offset)
        offset += varint.encode.bytes
        Record.encode(obj.records[i], buf, offset)
        offset += Record.encode.bytes
      }
    }
    if (defined(obj.meta)) {
      var tmp = Object.keys(obj.meta)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.meta[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 26
        varint.encode(Map_string_bytes.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_bytes.encode(tmp[i], buf, offset)
        offset += Map_string_bytes.encode.bytes
      }
    }
    if (defined(obj.finished)) {
      buf[offset++] = 32
      encodings.bool.encode(obj.finished, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.error)) {
      buf[offset++] = 42
      varint.encode(RemoteError.encodingLength(obj.error), buf, offset)
      offset += varint.encode.bytes
      RemoteError.encode(obj.error, buf, offset)
      offset += RemoteError.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      resourceId: 0,
      records: [],
      meta: {},
      finished: true,
      error: null
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.records.push(Record.decode(buf, offset, offset + len))
        offset += Record.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_bytes.decode(buf, offset, offset + len)
        obj.meta[tmp.key] = tmp.value
        offset += Map_string_bytes.decode.bytes
        break
        case 4:
        obj.finished = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 5:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.error = RemoteError.decode(buf, offset, offset + len)
        offset += RemoteError.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineOnUpdateRequest () {
  OnUpdateRequest.encodingLength = encodingLength
  OnUpdateRequest.encode = encode
  OnUpdateRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (!defined(obj.head)) throw new Error("head is required")
    var len = encodings.varint.encodingLength(obj.head)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.head)) throw new Error("head is required")
    buf[offset++] = 24
    encodings.varint.encode(obj.head, buf, offset)
    offset += encodings.varint.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      resourceId: 0,
      head: 0
    }
    var found0 = false
    var found1 = false
    var found2 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.head = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found2 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSyncRequest () {
  SyncRequest.encodingLength = encodingLength
  SyncRequest.encode = encode
  SyncRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.id)) throw new Error("id is required")
    var len = encodings.varint.encodingLength(obj.id)
    length += 1 + len
    if (defined(obj.views)) {
      for (var i = 0; i < obj.views.length; i++) {
        if (!defined(obj.views[i])) continue
        var len = encodings.string.encodingLength(obj.views[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.id)) throw new Error("id is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.id, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.views)) {
      for (var i = 0; i < obj.views.length; i++) {
        if (!defined(obj.views[i])) continue
        buf[offset++] = 18
        encodings.string.encode(obj.views[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      id: 0,
      views: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.id = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.views.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCommandRequest () {
  CommandRequest.encodingLength = encodingLength
  CommandRequest.encode = encode
  CommandRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (!defined(obj.command)) throw new Error("command is required")
    var len = encodings.string.encodingLength(obj.command)
    length += 1 + len
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        var len = Arg.encodingLength(obj.args[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    if (defined(obj.env)) {
      var tmp = Object.keys(obj.env)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.env[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        var len = Map_string_string.encodingLength(tmp[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.command)) throw new Error("command is required")
    buf[offset++] = 18
    encodings.string.encode(obj.command, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        buf[offset++] = 26
        varint.encode(Arg.encodingLength(obj.args[i]), buf, offset)
        offset += varint.encode.bytes
        Arg.encode(obj.args[i], buf, offset)
        offset += Arg.encode.bytes
      }
    }
    if (defined(obj.env)) {
      var tmp = Object.keys(obj.env)
      for (var i = 0; i < tmp.length; i++) {
        tmp[i] = {key: tmp[i], value: obj.env[tmp[i]]}
      }
      for (var i = 0; i < tmp.length; i++) {
        if (!defined(tmp[i])) continue
        buf[offset++] = 34
        varint.encode(Map_string_string.encodingLength(tmp[i]), buf, offset)
        offset += varint.encode.bytes
        Map_string_string.encode(tmp[i], buf, offset)
        offset += Map_string_string.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      resourceId: 0,
      command: "",
      args: [],
      env: {}
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.command = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.args.push(Arg.decode(buf, offset, offset + len))
        offset += Arg.decode.bytes
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        var tmp = Map_string_string.decode(buf, offset, offset + len)
        obj.env[tmp.key] = tmp.value
        offset += Map_string_string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCommandResponse () {
  CommandResponse.encodingLength = encodingLength
  CommandResponse.encode = encode
  CommandResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.value)) {
      var len = encodings.bytes.encodingLength(obj.value)
      length += 1 + len
    }
    if (defined(obj.finished)) {
      var len = encodings.bool.encodingLength(obj.finished)
      length += 1 + len
    }
    if (defined(obj.error)) {
      var len = RemoteError.encodingLength(obj.error)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.value)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.value, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.finished)) {
      buf[offset++] = 16
      encodings.bool.encode(obj.finished, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.error)) {
      buf[offset++] = 26
      varint.encode(RemoteError.encodingLength(obj.error), buf, offset)
      offset += varint.encode.bytes
      RemoteError.encode(obj.error, buf, offset)
      offset += RemoteError.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      value: null,
      finished: false,
      error: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.finished = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.error = RemoteError.decode(buf, offset, offset + len)
        offset += RemoteError.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStreamRequest () {
  StreamRequest.encodingLength = encodingLength
  StreamRequest.encode = encode
  StreamRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    var len = encodings.varint.encodingLength(obj.resourceId)
    length += 1 + len
    if (!defined(obj.streamId)) throw new Error("streamId is required")
    var len = encodings.varint.encodingLength(obj.streamId)
    length += 1 + len
    if (defined(obj.data)) {
      var len = encodings.bytes.encodingLength(obj.data)
      length += 1 + len
    }
    if (defined(obj.finished)) {
      var len = encodings.bool.encodingLength(obj.finished)
      length += 1 + len
    }
    if (defined(obj.error)) {
      var len = RemoteError.encodingLength(obj.error)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.resourceId)) throw new Error("resourceId is required")
    buf[offset++] = 8
    encodings.varint.encode(obj.resourceId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (!defined(obj.streamId)) throw new Error("streamId is required")
    buf[offset++] = 16
    encodings.varint.encode(obj.streamId, buf, offset)
    offset += encodings.varint.encode.bytes
    if (defined(obj.data)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.finished)) {
      buf[offset++] = 32
      encodings.bool.encode(obj.finished, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.error)) {
      buf[offset++] = 42
      varint.encode(RemoteError.encodingLength(obj.error), buf, offset)
      offset += varint.encode.bytes
      RemoteError.encode(obj.error, buf, offset)
      offset += RemoteError.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      resourceId: 0,
      streamId: 0,
      data: null,
      finished: false,
      error: null
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.resourceId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found0 = true
        break
        case 2:
        obj.streamId = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        found1 = true
        break
        case 3:
        obj.data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 4:
        obj.finished = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 5:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.error = RemoteError.decode(buf, offset, offset + len)
        offset += RemoteError.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineStatusResponse () {
  StatusResponse.encodingLength = encodingLength
  StatusResponse.encode = encode
  StatusResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.live)) throw new Error("live is required")
    var len = encodings.bool.encodingLength(obj.live)
    length += 1 + len
    if (defined(obj.uptime)) {
      var len = encodings.varint.encodingLength(obj.uptime)
      length += 1 + len
    }
    if (defined(obj.commandStatus)) {
      for (var i = 0; i < obj.commandStatus.length; i++) {
        if (!defined(obj.commandStatus[i])) continue
        var len = CommandStatus.encodingLength(obj.commandStatus[i])
        length += varint.encodingLength(len)
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.live)) throw new Error("live is required")
    buf[offset++] = 8
    encodings.bool.encode(obj.live, buf, offset)
    offset += encodings.bool.encode.bytes
    if (defined(obj.uptime)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.uptime, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.commandStatus)) {
      for (var i = 0; i < obj.commandStatus.length; i++) {
        if (!defined(obj.commandStatus[i])) continue
        buf[offset++] = 26
        varint.encode(CommandStatus.encodingLength(obj.commandStatus[i]), buf, offset)
        offset += varint.encode.bytes
        CommandStatus.encode(obj.commandStatus[i], buf, offset)
        offset += CommandStatus.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      live: false,
      uptime: 0,
      commandStatus: []
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.live = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        found0 = true
        break
        case 2:
        obj.uptime = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.commandStatus.push(CommandStatus.decode(buf, offset, offset + len))
        offset += CommandStatus.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineCommandStatus () {
  CommandStatus.encodingLength = encodingLength
  CommandStatus.encode = encode
  CommandStatus.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.name)) throw new Error("name is required")
    var len = encodings.string.encodingLength(obj.name)
    length += 1 + len
    if (!defined(obj.streaming)) throw new Error("streaming is required")
    var len = encodings.bool.encodingLength(obj.streaming)
    length += 1 + len
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.name)) throw new Error("name is required")
    buf[offset++] = 10
    encodings.string.encode(obj.name, buf, offset)
    offset += encodings.string.encode.bytes
    if (!defined(obj.streaming)) throw new Error("streaming is required")
    buf[offset++] = 16
    encodings.bool.encode(obj.streaming, buf, offset)
    offset += encodings.bool.encode.bytes
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      streaming: false
    }
    var found0 = false
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.streaming = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        found1 = true
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRPCError () {
  RPCError.encodingLength = encodingLength
  RPCError.encode = encode
  RPCError.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.message)) throw new Error("message is required")
    var len = encodings.string.encodingLength(obj.message)
    length += 1 + len
    if (defined(obj.code)) {
      var len = encodings.string.encodingLength(obj.code)
      length += 1 + len
    }
    if (defined(obj.errno)) {
      var len = encodings.int32.encodingLength(obj.errno)
      length += 1 + len
    }
    if (defined(obj.details)) {
      var len = encodings.string.encodingLength(obj.details)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.message)) throw new Error("message is required")
    buf[offset++] = 10
    encodings.string.encode(obj.message, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.code)) {
      buf[offset++] = 18
      encodings.string.encode(obj.code, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.errno)) {
      buf[offset++] = 24
      encodings.int32.encode(obj.errno, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.details)) {
      buf[offset++] = 34
      encodings.string.encode(obj.details, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      message: "",
      code: "",
      errno: 0,
      details: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.message = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.code = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.errno = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 4:
        obj.details = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMap_string_bytes () {
  Map_string_bytes.encodingLength = encodingLength
  Map_string_bytes.encode = encode
  Map_string_bytes.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.string.encodingLength(obj.key)
    length += 1 + len
    if (defined(obj.value)) {
      var len = encodings.bytes.encodingLength(obj.value)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.string.encode(obj.key, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.value)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.value, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: "",
      value: null
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.value = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMap_string_Type () {
  Map_string_Type.encodingLength = encodingLength
  Map_string_Type.encode = encode
  Map_string_Type.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.string.encodingLength(obj.key)
    length += 1 + len
    if (defined(obj.value)) {
      var len = Type.encodingLength(obj.value)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.string.encode(obj.key, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.value)) {
      buf[offset++] = 18
      varint.encode(Type.encodingLength(obj.value), buf, offset)
      offset += varint.encode.bytes
      Type.encode(obj.value, buf, offset)
      offset += Type.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: "",
      value: null
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.value = Type.decode(buf, offset, offset + len)
        offset += Type.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMap_string_string () {
  Map_string_string.encodingLength = encodingLength
  Map_string_string.encode = encode
  Map_string_string.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.key)) throw new Error("key is required")
    var len = encodings.string.encodingLength(obj.key)
    length += 1 + len
    if (defined(obj.value)) {
      var len = encodings.string.encodingLength(obj.value)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.key)) throw new Error("key is required")
    buf[offset++] = 10
    encodings.string.encode(obj.key, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.value)) {
      buf[offset++] = 18
      encodings.string.encode(obj.value, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      key: "",
      value: ""
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.key = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.value = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
